### Go Slice vs Pointer Patterns

このリポジトリは、Goにおけるスライスとポインタの3パターンの挙動と、実務を想定したワークロードでの性能差を確認するためのサンプルコード集です。主に以下の3つを比較します。

- A: `[]User`（値スライス）
- B: `*[]User`（スライス全体のポインタ）
- C: `[]*User`（要素がポインタ）

実装は以下を含みます。
- `main.go`: A/B/C各パターンの挙動デモ（nil/空/共有性など）
- `bench_test.go`: 代表的な処理に対するベンチマーク

### 使い方

前提: Go 1.22+

挙動デモの実行:
```bash
go run .
```

ベンチマークの実行:
```bash
go test -bench . -benchmem
```

### ベンチマーク項目

- 基本操作: 走査（Iterate）/ コピー（Copy）/ 更新（Update）
- JSON: Marshal / JSON Lines
- 実ワークロード例: DTO変換 / フィルタ / ソート / グルーピング

ベンチ結果はマシンやGoのバージョンにより変動します。傾向として、巨大構造体を扱う場面やコピーが多い処理では `[]*User` が有利、状態をシンプルに保ちたい場合は `[]User` がデフォルト選択肢になります。`*[]User` は状態表現（nil/空/値あり）の厳密化が目的で、性能上の優位は限定的です。

### 参考

- 記事: なんとなく使っている配列とポインタとは？（比較・ベンチマークまとめ）
  - [Zenn: なんとなく使っている配列とポインタとは？](https://zenn.dev/135yshr/articles/900df6caad67e6)
